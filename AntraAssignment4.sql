--1. A view is a virtual table whose contents are defined by a query.
--   Benifits:
--   a. To Simplify Data Manipulation
--   b. views enable you to create a backward compatible interface for a table when its schema changes
--   c. To Customize Data
--   d. Distributed queries can also be used to define views that use data from multiple heterogeneous sources 

--2. Yes. The modified data will be changed in the base table.

--3. A stored procedure groups one or more Transact-SQL statements into a logical unit, stored as an object in a SQL Server database
--   Benifits:
--   a. Increase database security
--   b. Faster execution
--   c. Stored procedures help centralize your Transact-SQL code in the data tier
--   d. Stored procedures can help reduce network traffic for larger ad hoc queries
--   e. Stored procedures encourage code reusability

--4. A view will create a virtual table, while a stored procedure could do some functions like inserting, updating and deleting.
--   When first execute the stored procedure, it will stored in the sql server. The next time you call it, SQL will reuse the optimal query access plan.
--   But view is just a virtual table, you can access the data you want using the table that generated by view.

--5. The function must return a value but in Stored Procedure it is optional
--   Functions can have only input parameters for it whereas Stored Procedures can have input or output parameters
--   Functions can be called from Procedure whereas Stored Procedures cannot be called from a Function
--   Functions can be used in a SQL statement but Stored Procedures cannot.
--   There could have INSERT, UPDATE, DELETE in Stored Procedures, but functions could not have.

--6. Yes.

--7. No. Because a stored procedure could return nothing or it could return multiple result sets.

--8. Triggers are a special type of stored procedure that get executed (fired) when a specific event happens
--   DDL triggers and DML triggers

--9. Enforce Integrity beyond simple Referential Integrity
--   Implement business rules
--   Maintain audit record of changes
--   Accomplish cascading updates and deletes

--10. Stored Procedure can be explicitly executed. While Triggers cannot be explicitly executed, they will execute automtically when a specific event happens
--    Stored Procedure can have input and output but Triggers cannot


--1.
--a.
Insert into Region values(5, 'Middle Earth')
--b.
Insert into Territories values(00001, 'Gondor', 5)
--c.
Insert into Employees values(10, 'King', 'Aragorn', null, null, null, null, null, null, null, null, null, null, null, null, null, null, null)
Insert into EmployeeTerritories values(10, 00001)

--2.
Update Territories set TerritoryDescription = 'Arnor' where TerritoryID = 00001

--3.
Delete from EmployeeTerritories where EmployeeID = 10
Delete from Employees where EmployeeID = 10
Delete from Territories where TerritoryID = 00001
Delete from Region where RegionID = 5

--4.
Create view view_product_order_wang
As
Select p.ProductName, sum(od.Quantity) as TotalQuantity
From Products p inner join [Order Details] od
On p.ProductID = od.ProductID
Group by p.ProductID, p.ProductName

--5.
Create proc sp_product_order_quantity_wang
@productID int,
@totalQuantity int out
As
Begin
	select @totalQuantity = sum(od.Quantity)
	From Products p inner join [Order Details] od
	On p.ProductID = od.ProductID
	Where p.ProductID = @productID
	Group by p.ProductID
End

declare @anstotalQuantity int
exec sp_product_order_quantity_wang 3, @anstotalQuantity out
print @anstotalQuantity

--6.
Create proc sp_product_order_city_wang
@productName char(20)
As
Begin
	select top 5 c.City
	From [Order Details] od inner join Orders o
	On od.OrderID = o.OrderID
	Inner join Customers c
	On o.CustomerID = c.CustomerID
	Inner join Products p
	On p.ProductID = od.ProductID
	Where p.ProductName = @productName
	Group by c.City
	Order by sum(od.Quantity) desc
End

exec sp_product_order_city_wang 'Chai'

--7.
Create proc sp_move_employees_wang
As
If exists
(select e.EmployeeID
from Employees e inner join EmployeeTerritories et
on e.EmployeeID = et.EmployeeID
inner join Territories t
on et.TerritoryID = t.TerritoryID
where t.TerritoryDescription = 'Tory')
Begin
	Insert into Territories values (00001, 'Stevens Point', 3)
	Update EmployeeTerritories set TerritoryID = 00001 where EmployeeID in (select e.EmployeeID
																			from Employees e inner join EmployeeTerritories et
																			on e.EmployeeID = et.EmployeeID
																			inner join Territories t
																			on et.TerritoryID = t.TerritoryID
																			where t.TerritoryDescription = 'Troy')
End

--8.
Create trigger trg_move
On EmployeeTerritories
After insert, update
As
If (select count(et.EmployeeID)
	from EmployeeTerritories et inner join Territories t
	on et.TerritoryID = t.TerritoryID
	where t.TerritoryDescription = 'Stevens Point') > 100
Begin
	Update EmployeeTerritories set TerritoryID = (select TerritoryID from Territories where TerritoryDescription = 'Troy') 
	where EmployeeID in (select e.EmployeeID
								from Employees e inner join EmployeeTerritories et
								on e.EmployeeID = et.EmployeeID
								inner join Territories t
								on et.TerritoryID = t.TerritoryID
								where t.TerritoryDescription = 'Stevens Point')
End

--9.
Create table city_wang (id int primary key, city char(20) not null)
Create table people_wang (id int primary key, name char(20) not null, city int foreign key references city_wang(id))

insert into city_wang values (1, 'Seattle'), (2, 'Green Bay')
insert into people_wang values (1, 'Aaron', 2), (2, 'Russell Wilson', 1), (3, 'Jody Nelson', 2)

insert into city_wang values (3, 'Madison')
update people_wang set city = (select id from city_wang where city = 'Madison') where city = (select id from city_wang where city = 'Seattle')
delete from city_wang where city = 'Seattle'

create view Packers_zixun_wang
as
select p.name
from people_wang p inner join city_wang c
on p.city = c.id
where c.city = 'Green Bay'

drop view Packers_zixun_wang
drop table people_wang
drop table city_wang

--10.
create proc sp_birthday_employees_wang
as
begin
	create table birthday_employees_wang (empName char(20))
	insert into birthday_employees_wang select FirstName+' '+LastName from Employees where datepart(mm, BirthDate) = 2
end

exec sp_birthday_employees_wang

drop table birthday_employees_wang

--11.
create proc sp_wang_1
as
begin
	select dt.City
	from
	(select c.CustomerID, c.ContactName,c.City, count(distinct od.ProductID) cnt
	from Customers c left join Orders o
	on c.CustomerID = o.CustomerID
	left join [Order Details] od
	on o.OrderID = od.OrderID
	group by c.CustomerID, c.ContactName, c.City) dt
	where dt.cnt <= 1
	group by dt.City
	having count(dt.CustomerID) >= 2
end

--???
create proc sp_wang_2
as 
begin
	select dt.City
	from
	(select c.CustomerID, c.ContactName,c.City, count(distinct od.ProductID) cnt
	from Customers c left join Orders o
	on c.CustomerID = o.CustomerID
	left join [Order Details] od
	on o.OrderID = od.OrderID
	group by c.CustomerID, c.ContactName, c.City) dt
	where dt.cnt <= 1
	intersect
	select City
	from Customers
	group by City
	having count(CustomerID) >= 2
end

--12.
select count(1)
from
(select * from t1 union select * from t2)

select count(1) from t1

select count(1) from t2

--If these three values are the same, t1 and t2 have the same data. Otherwise they don't have the same data.

--14. ???
select [First Name] + ' ' + [Last Name] + ' ' + [Middle Name] + '.' as [Full Name]
from t

--15.
select top 1 Marks
from t
where Sex = 'F'
order by Marks desc

--16.
select Student, Marks, Sex
from t
order by Sex, Marks desc